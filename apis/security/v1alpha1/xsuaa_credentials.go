package v1alpha1

import (
	"context"
	"encoding/json"

	corev1 "k8s.io/api/core/v1"
	client "sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/crossplane/crossplane-runtime/pkg/resource"
	"github.com/pkg/errors"
)

var InvalidXsuaaCredentials = "invalid xsuaa api credentials"
var InvalidSourceReference = "invalid source reference"

// XsuaaBinding defines the json structure stored in secret to configure xsuaa api client
type XsuaaBinding struct {
	ClientId     string `json:"clientid"`
	ClientSecret string `json:"clientsecret"`
	TokenURL     string `json:"tokenurl"`
	ApiUrl       string `json:"apiurl"`
}

func ReadXsuaaCredentialsCustom(creds []byte) (*XsuaaBinding, error) {
	var binding = &XsuaaBinding{}
	if err := json.Unmarshal(creds, &binding); err != nil {
		return binding, errors.Wrap(err, InvalidXsuaaCredentials)
	}
	if binding.ClientId == "" || binding.ClientSecret == "" || binding.TokenURL == "" || binding.ApiUrl == "" {
		return binding, errors.New(InvalidXsuaaCredentials)
	}
	return binding, nil
}

func ReadXsuaaCredentialsUpjet(creds corev1.Secret) (*XsuaaBinding, error) {
	var binding = &XsuaaBinding{}
	if creds.Data == nil {
		return nil, errors.New(InvalidXsuaaCredentials)
	}
	// These keys are generated by upjet look into config.go if you want to change them
	apiUrl, ok := creds.Data["attribute.api_url"]
	if !ok {
		return nil, errors.New(InvalidXsuaaCredentials)
	}
	clientId, ok := creds.Data["attribute.client_id"]
	if !ok {
		return nil, errors.New(InvalidXsuaaCredentials)
	}
	clientSecret, ok := creds.Data["attribute.client_secret"]
	if !ok {
		return nil, errors.New(InvalidXsuaaCredentials)
	}
	tokenUrl, ok := creds.Data["attribute.token_url"]
	if !ok {
		return nil, errors.New(InvalidXsuaaCredentials)
	}

	binding.ApiUrl = string(apiUrl)
	binding.ClientId = string(clientId)
	binding.ClientSecret = string(clientSecret)
	binding.TokenURL = string(tokenUrl)

	return binding, nil
}

// DeterminBindingSource determines the source of the binding, defaults to a direct secret reference
func DeterminBindingSource(cr *XSUAACredentialsReference) (*bool, error) {

	if cr.APICredentials.Source != "" {
		value := true
		return &value, nil
	} else if cr.SubaccountApiCredentialRef != nil {
		value := false
		return &value, nil
	}
	return nil, errors.New(InvalidSourceReference)
}

// CreateBindingFromSource creates a binding from the source specified in the spec
func CreateBindingFromSource(cr *XSUAACredentialsReference, ctx context.Context, kube client.Client) (*XsuaaBinding, error) {

	useApiCredentials, err := DeterminBindingSource(cr)
	if err != nil {
		return nil, errors.Wrap(err, InvalidSourceReference)
	}

	if *useApiCredentials {
		// We default to the secret source if it is set
		secretBytes, err := resource.CommonCredentialExtractor(
			ctx,
			cr.APICredentials.Source,
			kube,
			cr.APICredentials.CommonCredentialSelectors,
		)

		if secretBytes == nil {
			return nil, errors.Wrap(err, InvalidXsuaaCredentials)
		}

		return ReadXsuaaCredentialsCustom(secretBytes)

	} else {
		// If the secret is not referenced directly, we need to get it from the subaccountapicredential
		secret := &corev1.Secret{}
		err := kube.Get(ctx, client.ObjectKey{Name: cr.SubaccountApiCredentialSecret, Namespace: cr.SubaccountApiCredentialSecretNamespace}, secret)

		if secret.Data == nil {
			return nil, errors.Wrap(err, InvalidXsuaaCredentials)
		}

		return ReadXsuaaCredentialsUpjet(*secret)

	}
}
